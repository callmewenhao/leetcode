# bit operator

## & 按位与运算

按位与运算有什么用？可以**判断某一位是否为 1**。
比如判断 k 的从右数第 j 位是否为1 就是 `if(k&(1<<j))`

**&** 一般被看作**集合的交集**。
比如，第 k 位是 1 代表这个集合有 k 这个元素，第 k 位是 0 表示这个集合没有 k 这个元素。
则**一个整数就是一个集合**，**两个集合的交**就是这**两个数字&起来**。这点非常有用，一定记住👏

另外，很容易证明，**与运算是不升的**，也就是说，一个数字不管怎么与，也不可能大于原数字。
这一点有些题可以用到 😜

## | 按位或运算

类比与运算，它就是每一位都进行“或者”操作。

这个运算一般用来**给集合赋值**。比如把 k 的二进制从右边数第 j 个改成 1（不管是不是1都改）就是：
`k |= (1<<j);`

**或运算**经常被用于作为**集合的并集**。
假设 a, b 是两个集合，那么他们的并就是 `a|b` 。这和与运算相反，也是一个非常重要的特性。

同时，**或运算是不降的**。也就是说，不管怎么或，也不可能产生的数字比原来数字还小（对于unsigned）。

## ^ 按位异或运算

异或运算被称为不进位加法。
异或最为重要的性质是 `x^y^y=x`，也就是说它的逆运算为本身！

## 左移操作 <<

把二进制所有位向左边移一位，**最低位补 0**，最高位移出去。

多数时候跟 `*2` 等价，但是一定注意 int 不要移到 31，这时候就会移到符号位， 
如果符号位为1，就变成负， 符号位0，还是正值。 
如果不想考虑这么麻烦，使用 `unsigned` 可以解决问题。

## 右移操作 >>

右移操作自然就是把所有位向右移动。超出右边的会自动去掉。
但是区别在于，它左边不是补 0，而是**补符号位**，对于 `unsigned` 不存在。


## 按位取反~

强调一下 `lowbit` 😁

```python
lowbit = n & -n  # n & (~n + 1)
```



