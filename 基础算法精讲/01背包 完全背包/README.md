# 背包问题

## 01 背包

0-1 背包：有 `n` 个物品，第 `i` 个物品的体积为 `w[i]`，
价值为 `v[i]` 每个物品至多选一个，
求体积和不超过 `capacity` 时的**最大价值和**

### 回溯三问

1. **当前操作？**
   枚举第 `i` 个物品选或不选：不选，剩余容量不变；选，剩余容量减少 `w[i]`

2. **子问题？**
   在剩余容量为 `c` 时，从前 `i` 个物品中得到的最大价值和

3. **下一个子问题？**
   分类讨论：
    - 不选：在剩余容量为 `c` 时，
      从前 `i-1` 个物品中得到的最大价值和
    - 选：在剩余容量为 `c-w[i]` 时，
      从前 `i-1` 个物品中得到的最大价值和

**公式：**
`dfs(i, c) = max(dfs(i-1, c), dfs(i-1, c - w[i]) + v[i])`

### 常见变形

**至多**装 `capacity`，求**方案数**/**最大价值和**

**恰好**装 `capacity`，求方案数/最大/最小价值和

**至少**装 `capacity`，求方案数/最小价值和

**方案数公式：**
`dfs(i, c) = dfs(i-1, c) + dfs(i-1, c-w[i])`
即为，**两种方案之和**

**最大价值和公式：**
`dfs(i, c) = max(dfs(i-1, c), dfs(i-1, c - w[i]) + v[i])`

**注意：** dfs 函数的返回值就是对应情况下的答案

### 记忆化搜索 改 递推

> 把 @cache 改成数组 `f` 存对应值 

递推公式：

```python
f[i][c] = f[i - 1][c] + f[i - 1][c - w[i]]
# 或者
f[i + 1][c] = f[i][c] + f[i][c - w[i]]
```

**一个数组：**

**01背包问题**的一维数组优化需要**倒着遍历**，
以避免覆盖掉要用的之前数据

## 完全背包

完全背包：有 `n` 种物品，
第 `i` 种物品的体积为 `w[i]`，
价值为 `v[i]` **每种物品无限次重复选**，
求体积和不超过 `capacity` 时的最大价值和

### 常见变形

**至多**装 `capacity`，求方案数/最大价值和

**恰好**装 `capacity`，求方案数/最大/**最小价值和**

**至少**装 `capacity`，求方案数/最小价值和

**搜索公式：**

```python
dfs(i, c) = min(dfs(i-1, c), dfs(i, c-w[i]) + v[i])
# 在求个数时，v[i] 会被 1 代替
```

**递推公式：**

```python
f[i][c] = min(f[i-1][c], f[i][c-w[i]]+v[i])
f[i+1][c] =min(f[i][c], f[i+1][c-w[i]]+v[i])
```

**一个数组：**

**完全背包问题**的一维数组优化就**不必倒着遍历**，因为表达式 
`f[i+1][c] =min(f[i][c], f[i+1][c-w[i]]+v[i])` 
中的 `f[i+1][c-w[i]]+v[i]` 是本行的值，而不是上一行的值 👏

```python
f[c] = min(f[c], f[c-w[i]]+v[i])
```

## 循环顺序

要用的元素是否可以被覆盖 决定了遍历方式

两种背包的遍历方式，具体查看对应的 **一维数组优化**

## 关注 dp 数组值的含义

不同的题目，所要的答案不同，
比如：**方案数，最大、小值，数字个数，能否构成**？

这也就意味着 dp 数组值可以为数值，也可以是 boolean 类型

另外，同样是数值的情况下，不同的要求，也会造成不同的初始值 `f[0][0]`：

- **能否构成：** `f[0][0] = True` **0** 可以构成 **0**

- **方案数：** `f[0][0] = 1` **0** 组成 **0** 只有一种方案

- **数字个数：** `f[0][0] = 0` **0** 组成 **0** 没有使用数字

- **最大、小值：** 问题一般会回归到 **方案数 或 数字个数问题**，
一般会使用到 `max/min` 函数约束答案，而且会使用 `+-inf` 初始化来表示极端情况。
比如：[力扣 279 求最小数量](https://leetcode.cn/problems/perfect-squares/)



